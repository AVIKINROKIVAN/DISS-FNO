# -*- coding: utf-8 -*-
"""[Diss] FenicsDataGen.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cYyKSkmbZO0ANX3gkD4t5uwX2v-xrKw-
"""

# Установка феникса

!apt-get install software-properties-common
!add-apt-repository ppa:fenics-packages/fenics
!apt-get update
!apt-get install --no-install-recommends fenics

try:
    import dolfin
except ImportError:
    !wget "https://fem-on-colab.github.io/releases/fenics-install-release-real.sh" -O "/tmp/fenics-install.sh" && bash "/tmp/fenics-install.sh"
    import dolfin

from fenics import *
import numpy as np
import scipy.io as sio
from tqdm import tqdm
import matplotlib.pyplot as plt
import os
from google.colab import drive

# Подключение Google Drive
drive.mount('/content/drive', force_remount=True)

# Оптимизация параметров FEniCS
parameters["form_compiler"]["optimize"] = True
parameters["form_compiler"]["cpp_optimize"] = True
parameters["form_compiler"]["representation"] = "uflacs"

# Параметры контроля качества
MAX_L2_ERROR = 0.1
MAX_ERROR = 0.1

# ==============================================
# 1. Функции генерации
# ==============================================

def generate_source():
    """Генерация случайного источника"""
    a = np.random.uniform(-1, 1)
    b = max(0.3, np.random.uniform(0.3, 1.0))
    c = np.random.uniform(-0.5, 0.5)
    return Expression(
        'a*exp(-(pow(x[0]-0.5, 2) + pow(x[1]-0.5, 2))/(b*b)) + c',
        degree=2, a=a, b=b, c=c
    )

def generate_boundary_conditions():
    """Генерация граничных условий"""
    coeff = np.random.uniform(-1, 1)
    choice = np.random.choice(['sin', 'linear', 'constant'])

    if choice == 'sin':
        return Expression(f'{coeff}*sin(pi*x[0])', degree=2)
    elif choice == 'linear':
        return Expression(f'{coeff}*x[0]', degree=1)
    else:
        return Expression(f'{coeff}', degree=0)

# ==============================================
# 2. Генератор данных с гарантией качества
# ==============================================

class DataGenerator:
    def __init__(self, num_examples=5000, grid_size=64):
        """Инициализация генератора данных"""
        self.num_examples = num_examples
        self.mesh = UnitSquareMesh(grid_size, grid_size)
        self.function_space = FunctionSpace(self.mesh, "P", 1)
        self.sources = []
        self.solutions = []

        # Определение границы
        def boundary(x, on_boundary):
            return on_boundary
        self.boundary = boundary

        # Пути для сохранения
        self.checkpoint_path = '/content/drive/MyDrive/Colab Notebooks/[Diss] FNO Model/DataTemp/Test/poisson_checkpoint.mat'
        self.final_path = '/content/drive/MyDrive/Colab Notebooks/[Diss] FNO Model/DataTemp/Test/poisson_dataset_final.mat'

    def load_checkpoint(self):
        """Загрузка последнего чекпоинта"""
        if os.path.exists(self.checkpoint_path):
            data = sio.loadmat(self.checkpoint_path)
            self.sources = data['source_data'].tolist()
            self.solutions = data['solution_data'].tolist()
            print(f"Загружен чекпоинт с {len(self.sources)} примерами")
            return len(self.sources)
        return 0

    def save_checkpoint(self):
        """Сохранение текущего прогресса"""
        if len(self.sources) > 0:
            sio.savemat(
                self.checkpoint_path,
                {
                    'source_data': np.array(self.sources),
                    'solution_data': np.array(self.solutions),
                    'mesh_coords': self.mesh.coordinates(),
                    'count': len(self.sources)
                }
            )

    def check_quality(self, solution, boundary_condition):
        """Проверка качества решения"""
        # Вычисление ошибки
        error = project(solution - boundary_condition, self.function_space)

        # L2 норма ошибки
        l2_error = norm(error, 'L2')

        # Максимальная ошибка
        error_array = error.vector().get_local()
        max_error = np.max(np.abs(error_array))

        return l2_error, max_error

    def generate_example(self):
        """Генерация одного качественного примера"""
        while True:
            # Генерация условий
            source = generate_source()
            boundary_condition = generate_boundary_conditions()

            # Решение уравнения Пуассона
            u = TrialFunction(self.function_space)
            v = TestFunction(self.function_space)
            a = dot(grad(u), grad(v)) * dx
            L = source * v * dx
            bc = DirichletBC(self.function_space, boundary_condition, self.boundary)

            solution = Function(self.function_space)
            solve(a == L, solution, bc)

            # Проверка качества
            l2_error, max_error = self.check_quality(solution, boundary_condition)

            if l2_error < MAX_L2_ERROR and max_error < MAX_ERROR:
                return (
                    project(source, self.function_space).vector().get_local(),
                    solution.vector().get_local()
                )

    def generate(self):
        """Основной цикл генерации"""
        start_index = self.load_checkpoint()

        try:
            current_count = len(self.sources)
            progress = tqdm(total=self.num_examples, initial=current_count, desc="Генерация данных")

            while current_count < self.num_examples:
                # Генерация нового качественного примера
                source, solution = self.generate_example()

                # Сохранение результатов
                self.sources.append(source)
                self.solutions.append(solution)
                current_count += 1
                progress.update(1)

                # Сохранение каждые 100 примеров
                if current_count % 100 == 0:
                    self.save_checkpoint()
                    tqdm.write(f"Сохранено на {current_count} примерах")

            # Финальное сохранение
            self.save_final_result()
            progress.close()

        except Exception as e:
            print(f"\nОшибка: {str(e)}")
            self.save_checkpoint()
            print(f"Прогресс сохранен на {len(self.sources)} примерах")
            raise

    def save_final_result(self):
        """Сохранение финального результата"""
        sio.savemat(
            self.final_path,
            {
                'source_data': np.array(self.sources),
                'solution_data': np.array(self.solutions),
                'mesh_coords': self.mesh.coordinates()
            }
        )
        if os.path.exists(self.checkpoint_path):
            os.remove(self.checkpoint_path)
        print(f"Финальный набор данных сохранен с {len(self.sources)} примерами")

# ==============================================
# 3. Запуск генерации
# ==============================================

if __name__ == "__main__":
    try:
        generator = DataGenerator(num_examples=5000, grid_size=64)
        print("Начало генерации набора данных...")
        print(f"Критерии качества: L2 ошибка < {MAX_L2_ERROR}, Макс ошибка < {MAX_ERROR}")
        generator.generate()

        # Визуализация первого примера
        plt.figure(figsize=(12, 5))

        plt.subplot(1, 2, 1)
        plt.tricontourf(generator.mesh.coordinates()[:, 0],
                       generator.mesh.coordinates()[:, 1],
                       generator.sources[0], levels=20, cmap='viridis')
        plt.colorbar()
        plt.title("Источник (f)")

        plt.subplot(1, 2, 2)
        plt.tricontourf(generator.mesh.coordinates()[:, 0],
                       generator.mesh.coordinates()[:, 1],
                       generator.solutions[0], levels=20, cmap='viridis')
        plt.colorbar()
        plt.title("Решение (u)")

        plt.tight_layout()
        plt.show()

    except KeyboardInterrupt:
        print("\nГенерация прервана пользователем!")
        if 'generator' in locals():
            generator.save_checkpoint()
            print(f"Последний чекпоинт на {len(generator.sources)} примерах")